package main

import (
	"fmt"
	"github.com/spf13/cobra"
	"html/template"
	"os"
	"time"
)

var buildInfoTemplate = `// Code generated by ziti-ci. DO NOT EDIT.

package {{.PackageName}}

const (
	Version   = "{{.Version}}"
	Revision  = "{{.Revision}}"
	Branch    = "{{.Branch}}"
	BuildUser = "{{.BuildUser}}"
	BuildDate = "{{.BuildDate}}"
)
`

type BuildInfo struct {
	PackageName string
	Version     string
	Revision    string
	Branch      string
	BuildUser   string
	BuildDate   string
}

type buildInfoCmd struct {
	baseCommand
}

func (cmd *buildInfoCmd) execute() {
	cmd.evalCurrentAndNextVersion()

	tagVersion := fmt.Sprintf("v%v", cmd.nextVersion)

	buildInfo := &BuildInfo{
		PackageName: cmd.args[1],
		Version:     tagVersion,
		Revision:    cmd.getCmdOutputOneLine("get git SHA", "git", "rev-parse", "--short=12", "HEAD"),
		Branch:      cmd.getCurrentBranch(),
		BuildUser:   cmd.getUsername(),
		BuildDate:   time.Now().Format("2006-01-02 15:04:05"),
	}

	compiledTemplate, err := template.New("buildInfo").Parse(buildInfoTemplate)
	if err != nil {
		cmd.failf("failure compiling build info template %+v\n", err)
	}

	file, err := os.Create(cmd.args[0])
	if err != nil {
		cmd.failf("failure opening build info output file %v. err: %+v\n", cmd.args[0], err)
	}

	err = compiledTemplate.Execute(file, buildInfo)
	if err != nil {
		cmd.failf("failure executing build template to output file %v. err: %+v\n", cmd.args[0], err)
	}

	cmd.runGitCommand("add build info file to git", "add", cmd.args[0])
	cmd.runGitCommand("commit build info file", "commit", "-m", fmt.Sprintf("Release %v", tagVersion))
}

func newBuildInfoCmd(root *rootCommand) *cobra.Command {
	cobraCmd := &cobra.Command{
		Use:   "generate-build-info output-file go-package",
		Short: "Tag and push command",
		Args:  cobra.ExactArgs(2),
	}

	result := &buildInfoCmd{
		baseCommand: baseCommand{
			rootCommand: root,
			cmd:         cobraCmd,
		},
	}

	return finalize(result)
}
